name: CI/CD Pipeline

on: push

permissions:
  contents: write
  issues: write
  pull-requests: write
  packages: write

env:
  PYTHON_VERSION: '3.13'
  SEMANTIC_VERSION: '19.0.2'
  working-dir: .

jobs:
  lint:
    name: Code Quality Checks
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: pip
          cache-dependency-path: |
            requirements.txt
            requirements-dev.txt

      - name: Cache linting tools
        uses: actions/cache@v4
        with:
          path: |
            .mypy_cache
            .ruff_cache
          key: lint-cache-${{ runner.os }}-${{ hashFiles('agentsmithy_server/**/*.py', 'main.py') }}
          restore-keys: |
            lint-cache-${{ runner.os }}-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt -r requirements-dev.txt

      - name: Check code formatting (Black)
        run: black --check .

      - name: Check import ordering (isort)
        run: isort --check-only .

      - name: Lint code (Ruff)
        run: ruff check .

      - name: Type check (MyPy)
        run: mypy agentsmithy_server

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: pip
          cache-dependency-path: |
            requirements.txt
            requirements-dev.txt

      - name: Cache pytest
        uses: actions/cache@v4
        with:
          path: |
            .pytest_cache
          key: pytest-cache-${{ runner.os }}-${{ hashFiles('tests/**/*.py', 'agentsmithy_server/**/*.py') }}
          restore-keys: |
            pytest-cache-${{ runner.os }}-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt -r requirements-dev.txt

      - name: Run tests with coverage
        run: pytest -v --cov=agentsmithy_server --cov-report=xml --cov-report=term-missing || test $? -eq 5

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          files: ./coverage.xml
          flags: unittests
          fail_ci_if_error: false
          verbose: true

      - name: Upload coverage artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage
          path: coverage.xml
          if-no-files-found: ignore

  semver:
    name: Release Version Management
    outputs:
      new_sha: ${{ steps.sha.outputs.SHA }}
      new_release_published: ${{ steps.semantic.outputs.new_release_published }}
      new_release_version: ${{ steps.semantic.outputs.new_release_version }}
    runs-on: ubuntu-latest
    needs: [lint, test]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Semantic Release
        id: semantic
        if: startsWith(github.ref, 'refs/heads/master') || startsWith(github.ref, 'refs/heads/main')
        uses: cycjimmy/semantic-release-action@v4
        with:
          semantic_version: ${{ env.SEMANTIC_VERSION }}
          extra_plugins: |
            @semantic-release/changelog@6.0.0
            @semantic-release/git@10.0.0
            @semantic-release/exec@6.0.1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Get SHA
        id: sha
        run: |
          sha_new=$(git rev-parse HEAD)
          echo $sha_new
          echo "SHA=$sha_new" >> $GITHUB_OUTPUT

      - run: echo ${{ steps.sha.outputs.SHA }}
      - run: echo "New release published=${{ steps.semantic.outputs.new_release_published }}"
      - run: echo "New release version=${{ steps.semantic.outputs.new_release_version }}"


  build_binaries:
    name: Build Executables
    runs-on: ${{ matrix.runner }}
    needs: [semver, lint, test]  # Add lint/test dependencies for tag builds
    # Build only when: new semantic release OR on tags (after lint/test pass)
    if: |
      (needs.semver.outputs.new_release_published == 'true') ||
      (startsWith(github.ref, 'refs/tags/') && needs.lint.result == 'success' && needs.test.result == 'success')
    strategy:
      fail-fast: false
      matrix:
        include:
          - runner: ubuntu-latest
            label: linux-amd64
            ext: ""
          # NOTE: Linux ARM64 on GitHub-hosted runners is not available on the free plan.
          # TODO: Enable when upgrading plan or using a self-hosted ARM64 runner.
          # - runner: ubuntu-24.04-arm64
          #   label: linux-arm64
          # Example for self-hosted ARM64 runner (labels must match your runner):
          # - runner: [self-hosted, Linux, ARM64]
          #   label: linux-arm64
          - runner: windows-latest
            label: windows-amd64
            ext: ".exe"
          - runner: macos-14
            label: macos-arm64
            ext: ""
          - runner: macos-13
            label: macos-amd64
            ext: ""
    steps:
      - name: Checkout code at release SHA or tag
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ startsWith(github.ref, 'refs/tags/') && github.ref || needs.semver.outputs.new_sha }}
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: pip
          cache-dependency-path: |
            requirements.txt
            requirements-dev.txt
      - name: Derive release tag and version
        id: ver
        shell: bash
        run: |
          if [ "${{ needs.semver.outputs.new_release_published }}" = "true" ]; then
            VER="${{ needs.semver.outputs.new_release_version }}"
            TAG="v$VER"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            TAG="${GITHUB_REF#refs/tags/}"
            VER="${TAG#v}"
            if [ -z "$VER" ]; then
              echo "Invalid tag format: $TAG (must start with 'v')" >&2
              exit 1
            fi
          else
            echo "No version available: not a new semantic release or tag push" >&2
            TAG=""
            VER=""
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "version=$VER" >> $GITHUB_OUTPUT
      - name: Install UPX for compression
        if: steps.ver.outputs.version != ''
        shell: bash
        run: |
          # Check if UPX is already installed
          if command -v upx >/dev/null 2>&1; then
            echo "UPX already installed: $(upx --version | head -1)"
            exit 0
          fi
          
          if [ "${{ runner.os }}" = "Linux" ]; then
            sudo apt-get update && sudo apt-get install -y upx-ucl
          elif [ "${{ runner.os }}" = "macOS" ]; then
            brew install upx
          elif [ "${{ runner.os }}" = "Windows" ]; then
            choco install upx -y
          fi
          upx --version
      - name: Install build dependencies
        if: steps.ver.outputs.version != ''
        shell: bash
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt -r requirements-dev.txt
      - name: Cache PyInstaller build
        if: steps.ver.outputs.version != ''
        uses: actions/cache@v4
        with:
          path: |
            build
            *.spec
          key: pyinstaller-${{ runner.os }}-${{ runner.arch }}-${{ hashFiles('requirements.txt', 'main.py', 'agentsmithy_server/**/*.py') }}
          restore-keys: |
            pyinstaller-${{ runner.os }}-${{ runner.arch }}-
            pyinstaller-${{ runner.os }}-
      - name: Build executable with PyInstaller
        if: steps.ver.outputs.version != ''
        shell: bash
        run: |
          pyinstaller --version
          
          # Detect UPX directory safely
          UPX_ARG=""
          if command -v upx >/dev/null 2>&1; then
            UPX_PATH="$(command -v upx)"
            UPX_DIR="$(dirname "$UPX_PATH")"
            UPX_ARG="--upx-dir=$UPX_DIR"
            echo "UPX found at: $UPX_PATH"
          else
            echo "Warning: UPX not found, building without compression"
          fi
          
          pyinstaller --onefile \
            --name agentsmithy \
            $UPX_ARG \
            --collect-submodules agentsmithy_server.tools \
            --collect-submodules agentsmithy_server.tools.builtin \
            --collect-submodules chromadb \
            --collect-submodules chromadb.telemetry.product \
            --collect-data chromadb \
            --collect-submodules tiktoken \
            --collect-submodules tiktoken_ext \
            --exclude-module pytest \
            --exclude-module pytest_asyncio \
            --exclude-module black \
            --exclude-module isort \
            --exclude-module mypy \
            --exclude-module ruff \
            main.py
          ls -lh dist/agentsmithy${{ matrix.ext }}
      - name: Rename artifacts with version and latest aliases
        if: steps.ver.outputs.version != ''
        shell: bash
        run: |
          set -euo pipefail
          EXT="${{ matrix.ext }}"
          SRC="dist/agentsmithy${EXT}"
          VER_NAME="dist/agentsmithy-${{ matrix.label }}-${{ steps.ver.outputs.version }}${EXT}"
          mv "$SRC" "$VER_NAME"
      - name: Smoke test - verify binary runs
        if: steps.ver.outputs.version != ''
        shell: bash
        run: |
          EXT="${{ matrix.ext }}"
          BINARY="dist/agentsmithy-${{ matrix.label }}-${{ steps.ver.outputs.version }}${EXT}"
          chmod +x "$BINARY"
          echo "Testing binary: $BINARY"
          
          # Test --help (should work without .env)
          "./$BINARY" --help > /dev/null 2>&1
          if [ $? -ne 0 ]; then
            echo "❌ Binary --help failed"
            exit 1
          fi
          echo "✓ Binary --help works"
          
          # Test running without args (should show usage and exit with code 2)
          set +e
          "./$BINARY" > /dev/null 2>&1
          exit_code=$?
          set -e
          
          if [ $exit_code -eq 2 ]; then
            echo "✓ Binary exits correctly when missing required args"
          elif [ $exit_code -eq 139 ] || [ $exit_code -eq 137 ]; then
            echo "❌ Binary crashed (segfault or similar)"
            exit 1
          else
            echo "⚠ Binary exited with unexpected code $exit_code (expected 2), but didn't crash"
          fi
      - name: Upload artifacts
        if: steps.ver.outputs.version != ''
        uses: actions/upload-artifact@v4
        with:
          name: agentsmithy-${{ matrix.label }}-${{ steps.ver.outputs.version }}
          retention-days: 1
          path: |
            dist/agentsmithy-${{ matrix.label }}-${{ steps.ver.outputs.version }}${{ matrix.ext }}
  release_upload:
    name: Publish Release Assets
    runs-on: ubuntu-latest
    needs: [build_binaries, semver]
    # Run only when build_binaries succeeded and we have a version
    if: needs.build_binaries.result == 'success' && (needs.semver.outputs.new_release_published == 'true' || startsWith(github.ref, 'refs/tags/'))
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v5
        with:
          pattern: agentsmithy-*
          merge-multiple: true
      - name: Derive tag and version
        id: tag
        shell: bash
        run: |
          if [ "${{ needs.semver.outputs.new_release_published }}" = "true" ]; then
            VER="${{ needs.semver.outputs.new_release_version }}"
            TAG="v$VER"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            TAG="${GITHUB_REF#refs/tags/}"
            VER="${TAG#v}"
            if [ -z "$VER" ]; then
              echo "Invalid tag format: $TAG (must start with 'v')" >&2
              exit 1
            fi
          else
            echo "No version available" >&2
            exit 1
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "version=$VER" >> $GITHUB_OUTPUT
      - name: Create/update release with assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tag.outputs.tag }}
          files: |
            agentsmithy-*



